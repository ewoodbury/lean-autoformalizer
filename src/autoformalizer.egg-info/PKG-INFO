Metadata-Version: 2.4
Name: autoformalizer
Version: 0.1.0
Summary: Lean autoformalization research toolkit.
Author: Autoformalizer Team
Requires-Python: >=3.11
Description-Content-Type: text/markdown
Requires-Dist: typer>=0.12.3
Requires-Dist: pydantic>=2.7.0
Requires-Dist: rich>=13.7.1
Requires-Dist: httpx>=0.27.0
Requires-Dist: pyyaml>=6.0.1
Requires-Dist: tqdm>=4.66.0
Provides-Extra: dev
Requires-Dist: pytest>=8.2.0; extra == "dev"
Requires-Dist: ruff>=0.6.5; extra == "dev"
Requires-Dist: pyrefly>=0.5.0; extra == "dev"

# lean-autoformalizer

Autoformalization pipeline of simple math proofs from English into Lean 4 (with Mathlib) via LLM.

## Results



## CLI Demo

Here's a demo of the autoformalizer in interactive mode:
- Set your OpenRouter key: `export OPENROUTER_API_KEY=sk-or-...`
- Run the interactive decoder: `make decode` or `uv run autoformalize decode`
- Enter a mathematical statement with proof steps to see the AI reasoning process
- (Optional) Specify proof steps separated by semicolons to guide the model

**Example 1: Simple application of a known theorem**
```
make decode
Starting interactive decoder...
Statement: For all natural numbers a, b, and c, a * (b + c) = a * b + a * c.
Proof steps: First apply distributivity of multiplication over addition; Then simplify using basic arithmetic properties

=== Lean Candidate ===
import Mathlib.Algebra.Ring.Basic

theorem distributivity_demo (a b c : ℕ) : a * (b + c) = a * b + a * c := by
  rw [Nat.mul_add]

Validation: Success! (4.2s)
```

**Example 2: Propositional logic with case analysis**
```
make decode
Statement: For propositions P, Q, and R, if P ∨ Q holds and each disjunct implies R, then R holds.
Proof steps: We perform case analysis on the disjunction P ∨ Q.” “If P holds we apply the implication from P to R, otherwise we apply the implication from Q to R.

=== Lean Candidate ===
theorem disjunction_elimination (P Q R : Prop) (h1 : P ∨ Q) (h2 : P → R) (h3 : Q → R) : R := by
  cases h1 with
  | inl hp => exact h2 hp
  | inr hq => exact h3 hq

Validation: Success! (10.54s)
```

## Local Setup

### Prerequisites
- [Lean 4 toolchain](https://leanprover-community.github.io/get_started.html) (Lake 5+, compatible with `leanprover/lean4:v4.18.0`).
- [`uv`](https://github.com/astral-sh/uv) ≥ 0.8 for Python dependency management.

### Lean environment
```bash
# Fetch mathlib and build the sample project targets
make build-lean

# Or run the helper script to confirm the environment is functional
make check-lean
```
The helper script runs `lake build Autoformalizer.Basic` followed by `lake build` to confirm that mathlib is available and the scaffolding compiles.

### Python environment
```bash
# Create a local virtualenv at .venv and install runtime+dev deps
./scripts/bootstrap_python.sh
```
After the sync you can invoke tooling with `uv run`:
```bash
uv run --python 3.11 --group dev ruff check
uv run --python 3.11 pytest
```

### Executor check
```bash
uv run python - <<'PY'
from autoformalizer.executor import run_proof

snippet = """
    theorem tmp (a b : Nat) : a + b = b + a := by
      simpa using Nat.add_comm a b
"""
print(run_proof(snippet))
PY
```
The call returns `(True, "")` when Lean accepts the generated snippet. Failures return `False` and emit compiler stderr for downstream prompt repair.

### CLI entrypoint
```bash
uv run autoformalize check Autoformalizer/Basic.lean
```
This wraps `run_proof` so Phase 0 can be driven from the command line.

#### Talking to an LLM (OpenRouter)

Set your OpenRouter key in the environment and invoke the new `decode` command to translate
English statements into Lean code through `x-ai/grok-4-fast`:

```bash
export OPENROUTER_API_KEY=sk-or-...
uv run autoformalize decode \
  --statement "For all natural numbers n, n + 0 = n" \
  --step "Use Nat.add_zero"
```

Run it fully interactively (no flags) via either command:

```bash
uv run autoformalize decode
# or
make decode
```

Flags you may find useful:

- `--model`: override the OpenRouter model (defaults to `x-ai/grok-4-fast`).
- `--max-tokens` / `--temperature`: control sampling parameters.
- `--show-prompt`: print the exact prompt sent to the model.
- `--output`: save the generated Lean snippet to a file.
- `--step`: optionally provide one or more proof hints (separate multiple steps with `;`).

The command validates the returned code with lightweight structural checks before printing the
result, so you immediately learn whether the snippet is syntactically plausible.

### Linting & formatting
`ruff` is configured as the single source of truth for linting and formatting. Use:
```bash
make lint
make format
```
