{"id": "nat_succ_mul_expand", "topic": "algebra.basic", "english": {"statement": "For all natural numbers a and b, (a + 1) * b = b + a * b.", "steps": ["We expand the product using the successor multiplication identity."]}, "lean": {"imports": [], "theorem": "theorem nat_succ_mul_expand (a b : Nat) : (a + 1) * b = b + a * b := by\n  simpa [Nat.succ_eq_add_one, Nat.add_comm, Nat.add_left_comm] using Nat.succ_mul a b"}}
{"id": "eq_symm", "topic": "logic.eq", "english": {"statement": "For any type \u03b1 and any elements a and b of type \u03b1, if a = b then b = a.", "steps": ["We use symmetry of equality."]}, "lean": {"imports": [], "theorem": "theorem eq_symm {\u03b1 : Type} {a b : \u03b1} (h : a = b) : b = a := Eq.symm h"}}
{"id": "prop_and_left", "topic": "logic.prop", "english": {"statement": "For propositions P and Q, from P \u2227 Q we can deduce P.", "steps": ["We project the left conjunct from the conjunction."]}, "lean": {"imports": [], "theorem": "theorem prop_and_left {P Q : Prop} (h : P \u2227 Q) : P :=\n  h.1"}}
{"id": "prop_and_right", "topic": "logic.prop", "english": {"statement": "For propositions P and Q, from P \u2227 Q we can deduce Q.", "steps": ["We project the right conjunct from the conjunction."]}, "lean": {"imports": [], "theorem": "theorem prop_and_right {P Q : Prop} (h : P \u2227 Q) : Q :=\n  h.2"}}
{"id": "nat_add_right_cancel", "topic": "nat.basic", "english": {"statement": "For all natural numbers a, b, and c, if a + c = b + c, then a = b.", "steps": ["We use the right cancellation property of addition on naturals."]}, "lean": {"imports": [], "theorem": "theorem nat_add_right_cancel (a b c : Nat) : a + c = b + c \u2192 a = b := Nat.add_right_cancel"}}
{"id": "nat_succ_lt_succ", "topic": "nat.order", "english": {"statement": "For all natural numbers a and b, if a < b then a + 1 < b + 1.", "steps": ["We apply the successor function to both sides of the strict inequality."]}, "lean": {"imports": [], "theorem": "theorem nat_succ_lt_succ {a b : Nat} (h : a < b) : a.succ < b.succ :=\n  Nat.succ_lt_succ h"}}
{"id": "nat_zero_add_left", "topic": "nat.order", "english": {"statement": "For all natural numbers a and b, 0 + (a + b) = a + b.", "steps": ["We remove the leading zero using the left identity of addition."]}, "lean": {"imports": [], "theorem": "theorem nat_zero_add_left (a b : Nat) : 0 + (a + b) = a + b :=\n  by simpa using Nat.zero_add (a + b)"}}
{"id": "list_reverse_reverse", "topic": "data.list", "english": {"statement": "For any list l, reversing l twice gives back the original list.", "steps": ["We use the involution property of list reversal."]}, "lean": {"imports": [], "theorem": "theorem list_reverse_reverse (l : List \u03b1) : l.reverse.reverse = l := List.reverse_reverse l"}}
{"id": "list_length_reverse", "topic": "data.list", "english": {"statement": "For any list l, the length of l.reverse equals the length of l.", "steps": ["We use the fact that reversal preserves list length."]}, "lean": {"imports": [], "theorem": "theorem list_length_reverse {\u03b1 : Type*} (l : List \u03b1) : l.reverse.length = l.length := List.length_reverse"}}
{"id": "list_map_append", "topic": "data.list", "english": {"statement": "For any function f and lists l and m, mapping f over l ++ m equals (l.map f) ++ (m.map f).", "steps": ["We use the distributive property of map over concatenation."]}, "lean": {"imports": [], "theorem": "theorem list_map_append {\u03b1 \u03b2 : Type*} (f : \u03b1 \u2192 \u03b2) (l m : List \u03b1) : (l ++ m).map f = l.map f ++ m.map f := List.map_append"}}
{"id": "set_inter_assoc", "topic": "set.basic", "english": {"statement": "For any sets A, B, and C, (A \u2229 B) \u2229 C = A \u2229 (B \u2229 C).", "steps": ["We use associativity of set intersection."]}, "lean": {"imports": [], "theorem": "theorem set_inter_assoc {\u03b1 : Type*} (A B C : Set \u03b1) : (A \u2229 B) \u2229 C = A \u2229 (B \u2229 C) := Set.inter_assoc A B C"}}
{"id": "set_union_self", "topic": "set.basic", "english": {"statement": "For any set A, A \u222a A = A.", "steps": ["We use the idempotent property of set union."]}, "lean": {"imports": [], "theorem": "theorem set_union_self {\u03b1 : Type*} (A : Set \u03b1) : A \u222a A = A := Set.union_self A"}}
{"id": "set_inter_self", "topic": "set.basic", "english": {"statement": "For any set A, A \u2229 A = A.", "steps": ["We use the idempotent property of set intersection."]}, "lean": {"imports": [], "theorem": "theorem set_inter_self {\u03b1 : Type*} (A : Set \u03b1) : A \u2229 A = A := Set.inter_self A"}}
{"id": "int_mul_assoc", "topic": "algebra.int", "english": {"statement": "For all integers a, b, and c, (a * b) * c = a * (b * c).", "steps": ["We use associativity of integer multiplication."]}, "lean": {"imports": [], "theorem": "theorem int_mul_assoc (a b c : Int) : (a * b) * c = a * (b * c) := Int.mul_assoc a b c"}}
{"id": "int_distrib_left", "topic": "algebra.int", "english": {"statement": "For all integers a, b, and c, a * (b + c) = a * b + a * c.", "steps": ["We use left distributivity of multiplication over addition for integers."]}, "lean": {"imports": [], "theorem": "theorem int_distrib_left (a b c : Int) : a * (b + c) = a * b + a * c := Int.mul_add a b c"}}
{"id": "int_neg_add", "topic": "algebra.int", "english": {"statement": "For any integer a, a + (-a) = 0.", "steps": ["We use the additive inverse property for integers."]}, "lean": {"imports": [], "theorem": "theorem int_neg_add (a : Int) : a + (-a) = 0 := Int.add_right_neg a"}}
{"id": "function_injective_comp", "topic": "function.basic", "english": {"statement": "If functions f and g are injective, then f \u2218 g is injective.", "steps": ["We show that injectivity is preserved under composition."]}, "lean": {"imports": [], "theorem": "theorem function_injective_comp {f : \u03b2 \u2192 \u03b3} {g : \u03b1 \u2192 \u03b2} (hf : Function.Injective f) (hg : Function.Injective g) : Function.Injective (f \u2218 g) := Function.Injective.comp hf hg"}}
{"id": "function_surjective_comp", "topic": "function.basic", "english": {"statement": "If functions f and g are surjective, then f \u2218 g is surjective.", "steps": ["We show that surjectivity is preserved under composition."]}, "lean": {"imports": [], "theorem": "theorem function_surjective_comp {f : \u03b2 \u2192 \u03b3} {g : \u03b1 \u2192 \u03b2} (hf : Function.Surjective f) (hg : Function.Surjective g) : Function.Surjective (f \u2218 g) := Function.Surjective.comp hf hg"}}
{"id": "eq_congr_fun", "topic": "logic.eq", "english": {"statement": "For equal functions f and g and any argument a, f a = g a.", "steps": ["We use function congruence for equality."]}, "lean": {"imports": [], "theorem": "theorem eq_congr_fun {\u03b1 \u03b2 : Type} {f g : \u03b1 \u2192 \u03b2} (h : f = g) (a : \u03b1) : f a = g a := congrFun h a"}}
{"id": "eq_congr_arg", "topic": "logic.eq", "english": {"statement": "For any function f and equal arguments a and b, f a = f b.", "steps": ["We use argument congruence for equality."]}, "lean": {"imports": [], "theorem": "theorem eq_congr_arg {\u03b1 \u03b2 : Type} {f : \u03b1 \u2192 \u03b2} {a b : \u03b1} (h : a = b) : f a = f b := congrArg f h"}}
{"id": "nat_succ_inj", "topic": "nat.basic", "english": {"statement": "For natural numbers m and n, if m + 1 = n + 1, then m = n.", "steps": ["We use injectivity of the successor function."]}, "lean": {"imports": [], "theorem": "theorem nat_succ_inj {m n : Nat} (h : m.succ = n.succ) : m = n := Nat.succ.inj h"}}
{"id": "nat_le_succ_self", "topic": "nat.order", "english": {"statement": "For any natural number n, n \u2264 n + 1.", "steps": ["We use the fact that any number is at most its successor."]}, "lean": {"imports": [], "theorem": "theorem nat_le_succ_self (n : Nat) : n \u2264 n.succ := Nat.le_succ n"}}
{"id": "nat_lt_succ_self", "topic": "nat.order", "english": {"statement": "For any natural number n, n < n + 1.", "steps": ["We use the fact that any number is strictly less than its successor."]}, "lean": {"imports": [], "theorem": "theorem nat_lt_succ_self (n : Nat) : n < n.succ := Nat.lt_succ_self n"}}
{"id": "prop_or_true", "topic": "logic.prop", "english": {"statement": "For any proposition P, P \u2228 True is equivalent to True.", "steps": ["We use the fact that True is an absorbing element for disjunction."]}, "lean": {"imports": [], "theorem": "theorem prop_or_true (P : Prop) : P \u2228 True \u2194 True := \u27e8fun _ => True.intro, fun _ => Or.inr True.intro\u27e9"}}
{"id": "nat_dvd_refl", "topic": "nat.divisibility", "english": {"statement": "For any natural number n, n divides n.", "steps": ["We use reflexivity of divisibility."]}, "lean": {"imports": [], "theorem": "theorem nat_dvd_refl (n : Nat) : n \u2223 n := \u27e81, by simp\u27e9"}}
{"id": "nat_dvd_trans", "topic": "nat.divisibility", "english": {"statement": "For natural numbers a, b, and c, if a divides b and b divides c, then a divides c.", "steps": ["We use transitivity of divisibility."]}, "lean": {"imports": [], "theorem": "theorem nat_dvd_trans {a b c : Nat} (h1 : a \u2223 b) (h2 : b \u2223 c) : a \u2223 c := by\n  rcases h1 with \u27e8k1, hk1\u27e9\n  rcases h2 with \u27e8k2, hk2\u27e9\n  exact \u27e8k1 * k2, by rw [hk2, hk1, Nat.mul_assoc]\u27e9"}}
