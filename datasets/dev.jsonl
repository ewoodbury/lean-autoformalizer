{"id": "nat_succ_ne_zero", "topic": "nat.basic", "english": {"statement": "For any natural number n, S(n) ≠ 0.", "steps": ["We use the fact that successor and zero are different constructors."]}, "lean": {"imports": [], "theorem": "theorem nat_succ_ne_zero (n : ℕ) : n.succ ≠ 0 := Nat.succ_ne_zero n"}}
{"id": "option_some_inj", "topic": "data.option", "english": {"statement": "For any values a and b, if some a = some b, then a = b.", "steps": ["We use injectivity of the some constructor."]}, "lean": {"imports": [], "theorem": "theorem option_some_inj {a b : α} (h : some a = some b) : a = b := Option.some.inj h"}}
{"id": "sum_inl_inj", "topic": "data.sum", "english": {"statement": "For any values a and b, if Sum.inl a = Sum.inl b, then a = b.", "steps": ["We use injectivity of the left injection."]}, "lean": {"imports": [], "theorem": "theorem sum_inl_inj {α β : Type*} {a c : α} (h : Sum.inl a = (@Sum.inl α β c)) : a = c := Sum.inl.inj h"}}
{"id": "nat_succ_add_eq_succ", "topic": "algebra.basic", "english": {"statement": "For all natural numbers a and b, (a + 1) + b = (a + b) + 1.", "steps": ["We use associativity and commutativity to move the successor across the sum."]}, "lean": {"imports": [], "theorem": "theorem nat_succ_add_eq_succ (a b : Nat) : (a + 1) + b = (a + b) + 1 := by\n  simpa [Nat.succ_eq_add_one, Nat.add_comm, Nat.add_left_comm, Nat.add_assoc]"}}
{"id": "eq_refl", "topic": "logic.eq", "english": {"statement": "For any type α and any element a of type α, a = a.", "steps": ["We use reflexivity of equality."]}, "lean": {"imports": [], "theorem": "theorem eq_refl {α : Type} (a : α) : a = a := Eq.refl a"}}
{"id": "prop_imp_refl", "topic": "logic.prop", "english": {"statement": "For any proposition P, if P holds then P holds.", "steps": ["We use the reflexivity of implication."]}, "lean": {"imports": [], "theorem": "theorem prop_imp_refl (P : Prop) : P → P :=\n  fun h => h"}}
{"id": "prop_not_not", "topic": "logic.prop", "english": {"statement": "For any proposition P, ¬¬P is equivalent to P.", "steps": ["We use the classical principle of double negation elimination."]}, "lean": {"imports": [], "theorem": "theorem prop_not_not (P : Prop) : ¬¬P ↔ P := Classical.not_not"}}
{"id": "list_nil_append", "topic": "data.list", "english": {"statement": "For any list l, [] ++ l = l.", "steps": ["We use the definition of append for empty lists."]}, "lean": {"imports": [], "theorem": "theorem list_nil_append {α : Type*} (l : List α) : [] ++ l = l := List.nil_append l"}}
{"id": "list_cons_append", "topic": "data.list", "english": {"statement": "For any element a and lists l₁ and l₂, (a :: l₁) ++ l₂ = a :: (l₁ ++ l₂).", "steps": ["We use the definition of append for non-empty lists."]}, "lean": {"imports": [], "theorem": "theorem list_cons_append {α : Type*} (a : α) (l₁ l₂ : List α) : (a :: l₁) ++ l₂ = a :: (l₁ ++ l₂) := rfl"}}
{"id": "set_union_comm", "topic": "set_theory.basic", "english": {"statement": "For any sets A and B, A ∪ B = B ∪ A.", "steps": ["We use the commutativity of union."]}, "lean": {"imports": [], "theorem": "theorem set_union_comm {α : Type*} (A B : Set α) : A ∪ B = B ∪ A := Set.union_comm A B"}}
{"id": "function_comp_assoc", "topic": "function.basic", "english": {"statement": "For functions f : β → γ, g : α → β, and h : γ → δ, (h ∘ f) ∘ g = h ∘ (f ∘ g).", "steps": ["We use associativity of function composition."]}, "lean": {"imports": [], "theorem": "theorem function_comp_assoc {α β γ δ : Type*} (f : β → γ) (g : α → β) (h : γ → δ) : (h ∘ f) ∘ g = h ∘ (f ∘ g) := rfl"}}
{"id": "prop_and_false", "topic": "logic.prop", "english": {"statement": "For any proposition P, P ∧ False is equivalent to False.", "steps": ["We use the fact that False is an absorbing element for conjunction."]}, "lean": {"imports": [], "theorem": "theorem prop_and_false (P : Prop) : P ∧ False ↔ False := ⟨fun h => h.2, False.elim⟩"}}
{"id": "nat_mul_one", "topic": "algebra.basic", "english": {"statement": "For any natural number n, n * 1 = n.", "steps": ["We use the right identity property of multiplication."]}, "lean": {"imports": [], "theorem": "theorem nat_mul_one (n : ℕ) : n * 1 = n := Nat.mul_one n"}}
{"id": "nat_one_mul", "topic": "algebra.basic", "english": {"statement": "For any natural number n, 1 * n = n.", "steps": ["We use the left identity property of multiplication."]}, "lean": {"imports": [], "theorem": "theorem nat_one_mul (n : ℕ) : 1 * n = n := Nat.one_mul n"}}