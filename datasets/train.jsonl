{"id": "nat_add_succ_eq_succ_add", "topic": "algebra.basic", "english": {"statement": "For any natural numbers a and b, a + (b + 1) = (a + b) + 1.", "steps": ["We rewrite the sum using the successor identity for addition."]}, "lean": {"imports": [], "theorem": "theorem nat_add_succ_eq_succ_add (a b : Nat) : a + (b + 1) = (a + b) + 1 := by\n  simpa [Nat.succ_eq_add_one, Nat.add_comm, Nat.add_left_comm, Nat.add_assoc]"}}
{"id": "nat_add_perm_abcd_abdc", "topic": "algebra.basic", "english": {"statement": "For all natural numbers a, b, c, and d, (((a + b) + c) + d) = (((a + b) + d) + c).", "steps": ["We rearrange the sum using associativity and commutativity of addition."]}, "lean": {"imports": [], "theorem": "theorem nat_add_perm_abcd_abdc (a b c d : Nat) : (((a + b) + c) + d) = (((a + b) + d) + c) := by\n  simp [Nat.add_assoc, Nat.add_comm, Nat.add_left_comm]"}}
{"id": "nat_mul_perm_abcd_abdc", "topic": "algebra.basic", "english": {"statement": "For all natural numbers a, b, c, and d, (((a * b) * c) * d) = (((a * b) * d) * c).", "steps": ["We rearrange the product using associativity and commutativity of multiplication."]}, "lean": {"imports": [], "theorem": "theorem nat_mul_perm_abcd_abdc (a b c d : Nat) : (((a * b) * c) * d) = (((a * b) * d) * c) := by\n  simp [Nat.mul_assoc, Nat.mul_comm, Nat.mul_left_comm]"}}
{"id": "prop_or_left", "topic": "logic.prop", "english": {"statement": "For propositions P and Q, if P holds then P \u2228 Q holds.", "steps": ["We inject the proof into the left side of the disjunction."]}, "lean": {"imports": [], "theorem": "theorem prop_or_left {P Q : Prop} (h : P) : P \u2228 Q :=\n  Or.inl h"}}
{"id": "prop_or_comm", "topic": "logic.prop", "english": {"statement": "For any propositions P and Q, P \u2228 Q is equivalent to Q \u2228 P.", "steps": ["We show both directions by case analysis on the disjunction."]}, "lean": {"imports": [], "theorem": "theorem prop_or_comm (P Q : Prop) : P \u2228 Q \u2194 Q \u2228 P := Or.comm"}}
{"id": "prop_and_comm", "topic": "logic.prop", "english": {"statement": "For any propositions P and Q, P \u2227 Q is equivalent to Q \u2227 P.", "steps": ["We show both directions by extracting the components and reordering them."]}, "lean": {"imports": [], "theorem": "theorem prop_and_comm (P Q : Prop) : P \u2227 Q \u2194 Q \u2227 P := And.comm"}}
{"id": "prop_imp_trans", "topic": "logic.prop", "english": {"statement": "For propositions P, Q, and R, if P implies Q and Q implies R then P implies R.", "steps": ["We compose two implications to obtain the desired result."]}, "lean": {"imports": [], "theorem": "theorem prop_imp_trans {P Q R : Prop} (h\u2081 : P \u2192 Q) (h\u2082 : Q \u2192 R) : P \u2192 R :=\n  fun hP => h\u2082 (h\u2081 hP)"}}
{"id": "prop_and_assoc", "topic": "logic.prop", "english": {"statement": "For any propositions P, Q, and R, (P \u2227 Q) \u2227 R is equivalent to P \u2227 (Q \u2227 R).", "steps": ["We show both directions by nested extraction and reconstruction of conjunctions."]}, "lean": {"imports": [], "theorem": "theorem prop_and_assoc (P Q R : Prop) : (P \u2227 Q) \u2227 R \u2194 P \u2227 (Q \u2227 R) := \u27e8fun h => \u27e8h.1.1, h.1.2, h.2\u27e9, fun h => \u27e8\u27e8h.1, h.2.1\u27e9, h.2.2\u27e9\u27e9"}}
{"id": "prop_or_assoc", "topic": "logic.prop", "english": {"statement": "For any propositions P, Q, and R, (P \u2228 Q) \u2228 R is equivalent to P \u2228 (Q \u2228 R).", "steps": ["We show both directions by nested case analysis on the disjunctions."]}, "lean": {"imports": [], "theorem": "theorem prop_or_assoc (P Q R : Prop) : (P \u2228 Q) \u2228 R \u2194 P \u2228 (Q \u2228 R) := \u27e8fun h => h.elim (fun h' => h'.elim Or.inl (Or.inr \u2218 Or.inl)) (Or.inr \u2218 Or.inr), fun h => h.elim (Or.inl \u2218 Or.inl) (fun h' => h'.elim (Or.inl \u2218 Or.inr) Or.inr)\u27e9"}}
{"id": "prop_and_left_comm", "topic": "logic.prop", "english": {"statement": "For propositions P, Q, and R, (P \u2227 Q) \u2227 R is equivalent to (Q \u2227 P) \u2227 R.", "steps": ["We reorganize the conjunctions by swapping the first two components."]}, "lean": {"imports": [], "theorem": "theorem prop_and_left_comm (P Q R : Prop) : (P \u2227 Q) \u2227 R \u2194 (Q \u2227 P) \u2227 R :=\n  by\n    constructor\n    \u00b7 intro h\n      rcases h with \u27e8hPQ, hR\u27e9\n      rcases hPQ with \u27e8hP, hQ\u27e9\n      exact \u27e8\u27e8hQ, hP\u27e9, hR\u27e9\n    \u00b7 intro h\n      rcases h with \u27e8hQP, hR\u27e9\n      rcases hQP with \u27e8hQ, hP\u27e9\n      exact \u27e8\u27e8hP, hQ\u27e9, hR\u27e9"}}
{"id": "nat_succ_add", "topic": "nat.basic", "english": {"statement": "For all natural numbers a and b, (a + 1) + b = a + (b + 1).", "steps": ["We rewrite using successor properties and commutativity."]}, "lean": {"imports": [], "theorem": "theorem nat_succ_add (a b : Nat) : (a + 1) + b = a + (b + 1) := by rw [Nat.add_assoc, Nat.add_comm 1 b]"}}
{"id": "nat_add_le_add_left", "topic": "nat.order", "english": {"statement": "For all natural numbers a, b, and c, if a \u2264 b then c + a \u2264 c + b.", "steps": ["We add the same natural number to both sides to preserve the inequality."]}, "lean": {"imports": [], "theorem": "theorem nat_add_le_add_left {a b c : Nat} (h : a \u2264 b) : c + a \u2264 c + b :=\n  Nat.add_le_add_left h c"}}
{"id": "nat_add_lt_add_left", "topic": "nat.order", "english": {"statement": "For all natural numbers a, b, and c, if a < b then c + a < c + b.", "steps": ["We add the same number to both sides of a strict inequality."]}, "lean": {"imports": [], "theorem": "theorem nat_add_lt_add_left {a b c : Nat} (h : a < b) : c + a < c + b :=\n  Nat.add_lt_add_left h c"}}
{"id": "nat_add_le_add_right", "topic": "nat.order", "english": {"statement": "For all natural numbers a, b, and c, if a \u2264 b then a + c \u2264 b + c.", "steps": ["We use monotonicity of addition on the right to maintain the inequality."]}, "lean": {"imports": [], "theorem": "theorem nat_add_le_add_right {a b c : Nat} (h : a \u2264 b) : a + c \u2264 b + c :=\n  Nat.add_le_add_right h c"}}
{"id": "nat_le_trans_chain", "topic": "nat.order", "english": {"statement": "For all natural numbers a, b, and c, if a \u2264 b and b \u2264 c then a \u2264 c.", "steps": ["We apply transitivity of the natural number ordering."]}, "lean": {"imports": [], "theorem": "theorem nat_le_trans_chain {a b c : Nat} (h\u2081 : a \u2264 b) (h\u2082 : b \u2264 c) : a \u2264 c :=\n  Nat.le_trans h\u2081 h\u2082"}}
{"id": "nat_lt_trans_chain", "topic": "nat.order", "english": {"statement": "For all natural numbers a, b, and c, if a < b and b < c then a < c.", "steps": ["We apply transitivity of the strict natural number ordering."]}, "lean": {"imports": [], "theorem": "theorem nat_lt_trans_chain {a b c : Nat} (h\u2081 : a < b) (h\u2082 : b < c) : a < c :=\n  Nat.lt_trans h\u2081 h\u2082"}}
{"id": "nat_lt_of_le_of_lt", "topic": "nat.order", "english": {"statement": "For natural numbers a, b, and c, if a \u2264 b and b < c then a < c.", "steps": ["We combine a non-strict and a strict inequality to derive a strict conclusion."]}, "lean": {"imports": [], "theorem": "theorem nat_lt_of_le_of_lt {a b c : Nat} (h\u2081 : a \u2264 b) (h\u2082 : b < c) : a < c :=\n  Nat.lt_of_le_of_lt h\u2081 h\u2082"}}
{"id": "nat_lt_of_lt_of_le", "topic": "nat.order", "english": {"statement": "For natural numbers a, b, and c, if a < b and b \u2264 c then a < c.", "steps": ["We apply the transitivity of < with a non-strict upper bound."]}, "lean": {"imports": [], "theorem": "theorem nat_lt_of_lt_of_le {a b c : Nat} (h\u2081 : a < b) (h\u2082 : b \u2264 c) : a < c :=\n  Nat.lt_of_lt_of_le h\u2081 h\u2082"}}
{"id": "nat_double_succ", "topic": "nat.order", "english": {"statement": "For all natural numbers a and b, (a + 1) + (b + 1) = (a + b) + 2.", "steps": ["We combine two successors and rewrite the sum in canonical form."]}, "lean": {"imports": [], "theorem": "theorem nat_double_succ (a b : Nat) : (a + 1) + (b + 1) = (a + b) + 2 :=\n  by simp [Nat.succ_eq_add_one, Nat.add_assoc, Nat.add_comm, Nat.add_left_comm]"}}
{"id": "list_append_assoc", "topic": "data.list", "english": {"statement": "For any lists l, m, and n, (l ++ m) ++ n = l ++ (m ++ n).", "steps": ["We use associativity of list concatenation."]}, "lean": {"imports": [], "theorem": "theorem list_append_assoc (l m n : List \u03b1) : (l ++ m) ++ n = l ++ (m ++ n) := List.append_assoc l m n"}}
{"id": "set_inter_comm", "topic": "set.basic", "english": {"statement": "For any sets A and B, A \u2229 B = B \u2229 A.", "steps": ["We use commutativity of set intersection."]}, "lean": {"imports": [], "theorem": "theorem set_inter_comm {\u03b1 : Type*} (A B : Set \u03b1) : A \u2229 B = B \u2229 A := Set.inter_comm A B"}}
{"id": "int_add_comm", "topic": "algebra.int", "english": {"statement": "For all integers a and b, a + b = b + a.", "steps": ["We use commutativity of integer addition."]}, "lean": {"imports": [], "theorem": "theorem int_add_comm (a b : Int) : a + b = b + a := Int.add_comm a b"}}
{"id": "int_mul_comm", "topic": "algebra.int", "english": {"statement": "For all integers a and b, a * b = b * a.", "steps": ["We use commutativity of integer multiplication."]}, "lean": {"imports": [], "theorem": "theorem int_mul_comm (a b : Int) : a * b = b * a := Int.mul_comm a b"}}
{"id": "function_id_comp", "topic": "function.basic", "english": {"statement": "For any function f, f \u2218 id = f.", "steps": ["We use the right identity property of function composition."]}, "lean": {"imports": [], "theorem": "theorem function_id_comp (f : \u03b1 \u2192 \u03b2) : f \u2218 id = f := Function.comp_id f"}}
{"id": "eq_trans", "topic": "logic.eq", "english": {"statement": "For any type \u03b1 and elements a, b, and c of type \u03b1, if a = b and b = c, then a = c.", "steps": ["We use transitivity of equality."]}, "lean": {"imports": [], "theorem": "theorem eq_trans {\u03b1 : Type} {a b c : \u03b1} (h1 : a = b) (h2 : b = c) : a = c := Eq.trans h1 h2"}}
{"id": "nat_zero_lt_succ", "topic": "nat.order", "english": {"statement": "For any natural number n, 0 < n + 1.", "steps": ["We use the fact that successors are always positive."]}, "lean": {"imports": [], "theorem": "theorem nat_zero_lt_succ (n : Nat) : 0 < n.succ := Nat.zero_lt_succ n"}}
{"id": "prop_true_and", "topic": "logic.prop", "english": {"statement": "For any proposition P, True \u2227 P is equivalent to P.", "steps": ["We use the fact that True is the left identity for conjunction."]}, "lean": {"imports": [], "theorem": "theorem prop_true_and (P : Prop) : True \u2227 P \u2194 P := \u27e8fun h => h.2, fun h => \u27e8True.intro, h\u27e9\u27e9"}}
{"id": "prop_false_or", "topic": "logic.prop", "english": {"statement": "For any proposition P, False \u2228 P is equivalent to P.", "steps": ["We use the fact that False is the left identity for disjunction."]}, "lean": {"imports": [], "theorem": "theorem prop_false_or (P : Prop) : False \u2228 P \u2194 P := \u27e8fun h => h.elim False.elim id, Or.inr\u27e9"}}
{"id": "option_some_ne_none", "topic": "data.option", "english": {"statement": "For any value a, some a \u2260 none.", "steps": ["We use the fact that some and none are distinct constructors."]}, "lean": {"imports": [], "theorem": "theorem option_some_ne_none (a : \u03b1) : some a \u2260 none := Option.some_ne_none a"}}
{"id": "sum_inl_ne_inr", "topic": "data.sum", "english": {"statement": "For any values a and b, Sum.inl a \u2260 Sum.inr b.", "steps": ["We use the fact that left and right injections are distinct."]}, "lean": {"imports": [], "theorem": "theorem sum_inl_ne_inr (a : \u03b1) (b : \u03b2) : Sum.inl a \u2260 Sum.inr b := Sum.inl_ne_inr"}}





{"id": "prop_and_left_comm", "topic": "logic.prop", "english": {"statement": "For propositions P, Q, and R, (P \u2227 Q) \u2227 R is equivalent to (Q \u2227 P) \u2227 R.", "steps": ["We reorganize the conjunctions by swapping the first two components."]}, "lean": {"imports": [], "theorem": "theorem prop_and_left_comm (P Q R : Prop) : (P \u2227 Q) \u2227 R \u2194 (Q \u2227 P) \u2227 R :=\n  by\n    constructor\n    \u00b7 intro h\n      rcases h with \u27e8hPQ, hR\u27e9\n      rcases hPQ with \u27e8hP, hQ\u27e9\n      exact \u27e8\u27e8hQ, hP\u27e9, hR\u27e9\n    \u00b7 intro h\n      rcases h with \u27e8hQP, hR\u27e9\n      rcases hQP with \u27e8hQ, hP\u27e9\n      exact \u27e8\u27e8hP, hQ\u27e9, hR\u27e9"}}

For propositions P, Q, and R, (P \u2227 Q) \u2227 R is equivalent to (Q \u2227 P) \u2227 R.
We reorganize the conjunctions by swapping the first two components.