{"id": "nat_add_comm", "topic": "algebra.basic", "english": {"statement": "For all natural numbers a and b, a + b = b + a.", "steps": ["We use commutativity of addition on naturals."]}, "lean": {"imports": [], "theorem": "theorem nat_add_comm (a b : Nat) : a + b = b + a := Nat.add_comm a b"}}
{"id": "nat_add_assoc", "topic": "algebra.basic", "english": {"statement": "For all natural numbers a, b, and c, (a + b) + c = a + (b + c).", "steps": ["We use associativity of addition on naturals."]}, "lean": {"imports": [], "theorem": "theorem nat_add_assoc (a b c : Nat) : (a + b) + c = a + (b + c) := Nat.add_assoc a b c"}}
{"id": "nat_zero_add", "topic": "algebra.basic", "english": {"statement": "For any natural number a, 0 + a = a.", "steps": ["We use the left identity property of zero for addition."]}, "lean": {"imports": [], "theorem": "theorem nat_zero_add (a : Nat) : 0 + a = a := Nat.zero_add a"}}
{"id": "nat_add_zero", "topic": "algebra.basic", "english": {"statement": "For any natural number a, a + 0 = a.", "steps": ["We use the right identity property of zero for addition."]}, "lean": {"imports": [], "theorem": "theorem nat_add_zero (a : Nat) : a + 0 = a := Nat.add_zero a"}}
{"id": "nat_mul_comm", "topic": "algebra.basic", "english": {"statement": "For all natural numbers a and b, a * b = b * a.", "steps": ["We use commutativity of multiplication on naturals."]}, "lean": {"imports": [], "theorem": "theorem nat_mul_comm (a b : Nat) : a * b = b * a := Nat.mul_comm a b"}}
{"id": "nat_mul_assoc", "topic": "algebra.basic", "english": {"statement": "For all natural numbers a, b, and c, (a * b) * c = a * (b * c).", "steps": ["We use associativity of multiplication on naturals."]}, "lean": {"imports": [], "theorem": "theorem nat_mul_assoc (a b c : Nat) : (a * b) * c = a * (b * c) := Nat.mul_assoc a b c"}}
{"id": "nat_one_mul", "topic": "algebra.basic", "english": {"statement": "For any natural number a, 1 * a = a.", "steps": ["We use the left identity property of one for multiplication."]}, "lean": {"imports": [], "theorem": "theorem nat_one_mul (a : Nat) : 1 * a = a := Nat.one_mul a"}}
{"id": "nat_mul_one", "topic": "algebra.basic", "english": {"statement": "For any natural number a, a * 1 = a.", "steps": ["We use the right identity property of one for multiplication."]}, "lean": {"imports": [], "theorem": "theorem nat_mul_one (a : Nat) : a * 1 = a := Nat.mul_one a"}}
{"id": "nat_left_distrib", "topic": "algebra.basic", "english": {"statement": "For all natural numbers a, b, and c, a * (b + c) = a * b + a * c.", "steps": ["We use left distributivity of multiplication over addition."]}, "lean": {"imports": [], "theorem": "theorem nat_left_distrib (a b c : Nat) : a * (b + c) = a * b + a * c := Nat.left_distrib a b c"}}
{"id": "nat_right_distrib", "topic": "algebra.basic", "english": {"statement": "For all natural numbers a, b, and c, (a + b) * c = a * c + b * c.", "steps": ["We use right distributivity of multiplication over addition."]}, "lean": {"imports": [], "theorem": "theorem nat_right_distrib (a b c : Nat) : (a + b) * c = a * c + b * c := Nat.right_distrib a b c"}}
{"id": "prop_and_comm", "topic": "logic.prop", "english": {"statement": "For any propositions P and Q, P ∧ Q is equivalent to Q ∧ P.", "steps": ["We show both directions by extracting the components and reordering them."]}, "lean": {"imports": [], "theorem": "theorem prop_and_comm (P Q : Prop) : P ∧ Q ↔ Q ∧ P := And.comm"}}
{"id": "prop_or_comm", "topic": "logic.prop", "english": {"statement": "For any propositions P and Q, P ∨ Q is equivalent to Q ∨ P.", "steps": ["We show both directions by case analysis on the disjunction."]}, "lean": {"imports": [], "theorem": "theorem prop_or_comm (P Q : Prop) : P ∨ Q ↔ Q ∨ P := Or.comm"}}
{"id": "prop_and_assoc", "topic": "logic.prop", "english": {"statement": "For any propositions P, Q, and R, (P ∧ Q) ∧ R is equivalent to P ∧ (Q ∧ R).", "steps": ["We show both directions by nested extraction and reconstruction of conjunctions."]}, "lean": {"imports": [], "theorem": "theorem prop_and_assoc (P Q R : Prop) : (P ∧ Q) ∧ R ↔ P ∧ (Q ∧ R) := ⟨fun h => ⟨h.1.1, h.1.2, h.2⟩, fun h => ⟨⟨h.1, h.2.1⟩, h.2.2⟩⟩"}}
{"id": "prop_or_assoc", "topic": "logic.prop", "english": {"statement": "For any propositions P, Q, and R, (P ∨ Q) ∨ R is equivalent to P ∨ (Q ∨ R).", "steps": ["We show both directions by nested case analysis on the disjunctions."]}, "lean": {"imports": [], "theorem": "theorem prop_or_assoc (P Q R : Prop) : (P ∨ Q) ∨ R ↔ P ∨ (Q ∨ R) := ⟨fun h => h.elim (fun h' => h'.elim Or.inl (Or.inr ∘ Or.inl)) (Or.inr ∘ Or.inr), fun h => h.elim (Or.inl ∘ Or.inl) (fun h' => h'.elim (Or.inl ∘ Or.inr) Or.inr)⟩"}}
{"id": "prop_not_not", "topic": "logic.prop", "english": {"statement": "For any proposition P, ¬¬P is equivalent to P.", "steps": ["We use the classical principle of double negation elimination."]}, "lean": {"imports": [], "theorem": "theorem prop_not_not (P : Prop) : ¬¬P ↔ P := Classical.not_not"}}
{"id": "eq_refl", "topic": "logic.eq", "english": {"statement": "For any type α and any element a of type α, a = a.", "steps": ["We use reflexivity of equality."]}, "lean": {"imports": [], "theorem": "theorem eq_refl {α : Type} (a : α) : a = a := Eq.refl a"}}
{"id": "eq_symm", "topic": "logic.eq", "english": {"statement": "For any type α and any elements a and b of type α, if a = b then b = a.", "steps": ["We use symmetry of equality."]}, "lean": {"imports": [], "theorem": "theorem eq_symm {α : Type} {a b : α} (h : a = b) : b = a := Eq.symm h"}}
{"id": "nat_succ_add", "topic": "nat.basic", "english": {"statement": "For all natural numbers a and b, (a + 1) + b = a + (b + 1).", "steps": ["We rewrite using successor properties and commutativity."]}, "lean": {"imports": [], "theorem": "theorem nat_succ_add (a b : Nat) : (a + 1) + b = a + (b + 1) := by rw [Nat.add_assoc, Nat.add_comm 1 b]"}}
{"id": "nat_add_left_cancel", "topic": "nat.basic", "english": {"statement": "For all natural numbers a, b, and c, if a + b = a + c, then b = c.", "steps": ["We use the left cancellation property of addition on naturals."]}, "lean": {"imports": [], "theorem": "theorem nat_add_left_cancel (a b c : Nat) : a + b = a + c → b = c := Nat.add_left_cancel"}}
{"id": "nat_add_right_cancel", "topic": "nat.basic", "english": {"statement": "For all natural numbers a, b, and c, if a + c = b + c, then a = b.", "steps": ["We use the right cancellation property of addition on naturals."]}, "lean": {"imports": [], "theorem": "theorem nat_add_right_cancel (a b c : Nat) : a + c = b + c → a = b := Nat.add_right_cancel"}}